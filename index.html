<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>ISC-2026 Results</title>

<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

<style>
body {
    font-family: Arial;
    margin: 20px;
    overflow: hidden; /* Prevent page scroll */
}

.table-container {
    overflow: auto;
    height: 80vh;      /* Scroll inside container */
    border: 1px solid #ccc;
}

table {
    border-collapse: collapse;
    width: auto;
    table-layout: auto;
}

th, td {
    border: 1px solid #ccc;
    padding: 4px 8px;
    white-space: nowrap;
    background: white;
}


input {
    width: 95%;
    box-sizing: border-box;
}
</style>

</head>

<body>

<h2>ISC-2026 Results</h2>
<div style="margin-bottom:15px;">
    <button onclick="switchTab('Cat1')">Cat1</button>
    <button onclick="switchTab('Cat2')">Cat2</button>
    <button onclick="switchTab('Cat3')">Cat3</button>
</div>
<div id="tableArea"></div>

<script>

const sheets = {
    Cat1: {
        url: "https://docs.google.com/spreadsheets/d/e/2PACX-1vQeBugtsvSMiAlwoZwg_QVXDFN0lMvKAj0bLHLEeyk8KCihgezOPw-1Mh0m7I-48fJvRpKWi9UGwXyc/pub?gid=1706593238&single=true&output=csv",
        frozenRows: 2,
        frozenCols: ["A","B"],
        hiddenCols: ["AA"]
    },
    Cat2: {
        url: "https://docs.google.com/spreadsheets/d/e/2PACX-1vQeBugtsvSMiAlwoZwg_QVXDFN0lMvKAj0bLHLEeyk8KCihgezOPw-1Mh0m7I-48fJvRpKWi9UGwXyc/pub?gid=1880374698&single=true&output=csv",
        frozenRows: 2,
        frozenCols: ["B","C"],
        hiddenCols: ["A","AA"]      
    },
    Cat3: {
        url: "https://docs.google.com/spreadsheets/d/e/2PACX-1vQeBugtsvSMiAlwoZwg_QVXDFN0lMvKAj0bLHLEeyk8KCihgezOPw-1Mh0m7I-48fJvRpKWi9UGwXyc/pub?gid=482846150&single=true&output=csv",
        frozenRows: 2,
        frozenCols: ["J","K"],
        hiddenCols: ["A","B","C","D","E","F","G","H","I","AA"]
    }
};

let fullData = [];
let configGlobal;
let hiddenIndexes = [];

function colLetterToIndex(letter) {
    let result = 0;
    for (let i = 0; i < letter.length; i++) {
        result *= 26;
        result += letter.charCodeAt(i) - 64;
    }
    return result - 1;
}

function showTab(tab) {
    configGlobal = sheets[tab];
    hiddenIndexes = configGlobal.hiddenCols.map(c => colLetterToIndex(c));

    Papa.parse(configGlobal.url, {
        download: true,
        complete: function(results) {
            fullData = results.data;
            renderTable();
        }
    });
}

function renderTable() {
    const container = document.getElementById("tableArea");
    container.innerHTML = "";

    const table = document.createElement("table");
    const thead = document.createElement("thead");

    for (let r = 0; r < configGlobal.frozenRows; r++) {
        const tr = document.createElement("tr");
        fullData[r].forEach((cell, i) => {
            if (hiddenIndexes.includes(i)) return;
            const th = document.createElement("th");
            th.textContent = cell;
            tr.appendChild(th);
        });
        thead.appendChild(tr);
    }

    const filterRow = document.createElement("tr");
    filterRow.className = "filter-row";
    fullData[0].forEach((_, i) => {
        if (hiddenIndexes.includes(i)) return;
        const th = document.createElement("th");
        const input = document.createElement("input");
        input.dataset.col = i;
        input.oninput = applyFilters;
        th.appendChild(input);
        filterRow.appendChild(th);
    });

    thead.appendChild(filterRow);
    table.appendChild(thead);

    const tbody = document.createElement("tbody");
    table.appendChild(tbody);

    const wrapper = document.createElement("div");
    wrapper.className = "table-container";
    wrapper.appendChild(table);
    container.appendChild(wrapper);
    
    applyFilters();
}

function applyFilters() {

    const inputs = document.querySelectorAll("thead input");
    const tbody = document.querySelector("tbody");
    tbody.innerHTML = "";

    const W = colLetterToIndex("W");
    const X = colLetterToIndex("X");
    const Z = colLetterToIndex("Z");
    const AA = colLetterToIndex("AA");

    let visibleRows = [];
    let counter = 0;

    for (let r = configGlobal.frozenRows; r < fullData.length; r++) {

        let row = [...fullData[r]];
        let show = true;

        inputs.forEach(input => {
            const colIndex = input.dataset.col;
            if (!input.value) return;
            const filterText = input.value.trim();
const cellValue = (row[colIndex] || "").trim();

if (filterText !== "") {

    // If both filter and cell are numeric → exact numeric match
    if (!isNaN(filterText) && !isNaN(cellValue)) {

        if (Number(cellValue) !== Number(filterText)) {
            show = false;
        }

    } else {

        // Text filtering (case insensitive contains)
        if (!cellValue.toLowerCase().includes(filterText.toLowerCase())) {
            show = false;
        }
    }
}
        });

        if (show) {
            counter++;
            row[AA] = counter;
            visibleRows.push(row);
        }
    }

    // ---- EXACT TIE LOGIC ----
    visibleRows.forEach((row, idx) => {

        const rank = row[AA];

        if (!rank) {
            row[Z] = "";
            return;
        }

        const prev = visibleRows.find(r => r[AA] == rank - 1);
        const next = visibleRows.find(r => r[AA] == rank + 1);

        if (prev && row[W] === prev[W] && row[X] === prev[X]) {
            row[Z] = prev[Z];
            return;
        }

        if (next && row[W] === next[W] && row[X] === next[X]) {

            const sameGroup = visibleRows.filter(r => 
                r[W] === row[W] && r[X] === row[X]
            );

            const maxRank = Math.max(...sameGroup.map(r => r[AA]));
            row[Z] = rank + "-" + maxRank;
            return;
        }

        row[Z] = rank;
    });

    // ---- RENDER ----
    visibleRows.forEach(row => {
        const tr = document.createElement("tr");
        row.forEach((cell, i) => {
            if (hiddenIndexes.includes(i)) return;
            const td = document.createElement("td");
            td.textContent = cell;
            tr.appendChild(td);
        });
        tbody.appendChild(tr);
    });

    setTimeout(() => {
    const table = document.querySelector("table");
    if (!table) return;

    autoSizeColumns();
    applyFrozenRows(table);
    applyFrozenColumns(table);

}, 0);
    
}

function autoSizeColumns() {

    const table = document.querySelector("table");
    if (!table) return;

    const rows = table.querySelectorAll("tr");
    if (rows.length === 0) return;

    const colCount = rows[0].children.length;

    // Remove existing colgroup if present
    let oldColGroup = table.querySelector("colgroup");
    if (oldColGroup) {
        oldColGroup.remove();
    }

    // Create new colgroup
    const colgroup = document.createElement("colgroup");
    const cols = [];

    for (let i = 0; i < colCount; i++) {
        const col = document.createElement("col");
        colgroup.appendChild(col);
        cols.push(col);
    }

    table.insertBefore(colgroup, table.firstChild);

    // Measure max content width per column
    for (let colIndex = 0; colIndex < colCount; colIndex++) {

        let maxWidth = 0;

        rows.forEach(row => {
            const cell = row.children[colIndex];
            if (!cell) return;

            // Reset width before measuring
            cell.style.width = "auto";

            const width = cell.scrollWidth;
            if (width > maxWidth) {
                maxWidth = width;
            }
        });

        cols[colIndex].style.width = (maxWidth + 20) + "px";
    }
}
    
function switchTab(tabName) {
    showTab(tabName);
}

function applyFrozenColumns(table) {

    const frozenCols = configGlobal.frozenCols || [];
    if (!frozenCols.length) return;

    const rows = Array.from(table.querySelectorAll("tr"));

    // Calculate cumulative column widths
    const colWidths = [];
    const firstRowCells = rows[0].children;

    for (let i = 0; i < firstRowCells.length; i++) {
        colWidths.push(firstRowCells[i].offsetWidth);
    }

    frozenCols.forEach((colLetter) => {

        const colIndex = colLetterToIndex(colLetter);

        let leftOffset = 0;
        for (let i = 0; i < colIndex; i++) {
            leftOffset += colWidths[i];
        }

        rows.forEach((row, rowIndex) => {

    const cell = row.children[colIndex];
    if (!cell) return;

    cell.style.position = "sticky";
    cell.style.left = leftOffset + "px";
    cell.style.background = "white";

    const sheetFrozenCount = configGlobal.frozenRows || 0;
    const filterRow = table.querySelector(".filter-row");
    const filterIndex = rows.indexOf(filterRow);

    // If cell is in frozen sheet row OR filter row
    if (rowIndex < sheetFrozenCount || rowIndex === filterIndex) {

        // Preserve top offset already applied by applyFrozenRows
        cell.style.zIndex = 7;

    } else {
        cell.style.zIndex = 5;
    }
});
    });
}

function applyFrozenRows(table) {

    const sheetFrozenCount = configGlobal.frozenRows || 0;
    const rows = Array.from(table.querySelectorAll("tr"));

    let cumulativeTop = 0;

    // 1️⃣ Freeze actual sheet rows
    for (let i = 0; i < sheetFrozenCount; i++) {

        const row = rows[i];
        const height = row.offsetHeight;

        Array.from(row.children).forEach(cell => {
            cell.style.position = "sticky";
            cell.style.top = cumulativeTop + "px";
            cell.style.background = "white";
            cell.style.zIndex = 4;
        });

        cumulativeTop += height;
    }

    // 2️⃣ Freeze filter row separately
    const filterRow = table.querySelector(".filter-row");

    if (filterRow) {

        const height = filterRow.offsetHeight;

        Array.from(filterRow.children).forEach(cell => {
            cell.style.position = "sticky";
            cell.style.top = cumulativeTop + "px";
            cell.style.background = "white";
            cell.style.zIndex = 4;
        });
    }
}    
showTab("Cat1");

</script>

</body>
</html>
